# Модульная архитектура Unity
- Проект организован как модульная архитектура: модули, системы и инфраструктурные сервисы.

## Zenject и управление зависимостями
- Для организации зависимостей проекта и внедрения сервисов используется Zenject (контейнер внедрения зависимостей для Unity). Это позволяет применить принцип инверсии управления (IoC/DI): компоненты не сами создают необходимые сервисы, а получают их из Zenject-контейнера. Ключевые моменты использования Zenject в архитектуре:

- **Создание объектов через Zenject:** как правило, все ненестатические объекты (сервисы, менеджеры, классы домена) создаются контейнером Zenject. Это упрощает передачу зависимостей через конструкторы или атрибут `[Inject]` и делает код легко тестируемым. Если класс не имеет никаких внешних зависимостей (его конструктор без параметров), можно создать его через `new` — но даже такие классы можно зарегистрировать в контейнере для единообразия.

- **Изоляция:** по архитектурному правилу прямое связывание визуальных компонентов с бизнес-логикой недопустимо. Например, нельзя внедрять компонент UI в класс, отвечающий за чистую логику, или наоборот.

- **Передача инфраструктурных сервисов:** сервисы инфраструктуры (например, шина событий, `DataManager`, `Config` и т.п.) можно прокидывать во все части проекта через Zenject. Класс логики может иметь в конструкторе `ISignalBus` или `IResourceManager` – контейнер внедрит реализацию. Это соответствует идее Dependency Inversion: высокоуровневые компоненты работают через интерфейсы, а инфраструктурная реализация предоставляется через DI.

- **Применение Zenject помогает соблюдать loose coupling:** компоненты запрашивают абстракции, а конкретная реализация «прикручивается» в одном месте (контейнере), что облегчает замену и мокирование сервисов. Встроенная поддержка DI делает модули слабо зависимыми и гибко настраиваемыми.

## Модули
- **Модуль** – это логически связанная группа классов и компонентов, объединённых одной функциональной задачей. Например, «система инвентаря» может быть отдельным модулем, или модуль «генератор карты». Принципы работы с модулями:

- **Инкапсуляция:** детали реализации внутри модуля скрыты от внешних компонентов. Модуль общается с внешним миром через чётко определённые интерфейсы или события. Внутри модуля его компоненты (UI, логика, данные) могут активно взаимодействовать.

- **Единичная ответственность:** каждый модуль решает одну конкретную задачу (например, управление инвентарём, обработка диалогов, генерация уровней и т.д.). Это упрощает поддержку и тестирование.

- **Независимость:** модули должны быть максимально автономными друг от друга. Между модулями связи минимальны: если нужно обменяться данными, модули делают это через инфраструктурные сервисы или события, а не вызывают друг друга напрямую.

- **Внутри Unity:** модуль может содержать несколько классов-сервисов и данных. Например, модуль «Генератор карты» может включать логику генерации, хранитель сгенерированной карты, и UI-инструменты для контроля генерации. Но всё это остаётся внутри модуля – внешние части видят только его публичный API или события.

> Такой модульный подход позволяет легко заменить часть функциональности (например, другой алгоритм генерации карты) без затрагивания остальной системы.

## Системы
- **Система** – это совокупность модулей, совместно реализующих более крупную функциональность проекта. Система может включать модули разных направлений (например, UI-модуль настроек, модуль логики настроек и инфраструктурный DataManager). Основные принципы:

- **Ясная модульность:** система делится на чётко отделённые модули с понятными обязанностями. Модули легко заменяются — например, можно создать альтернативный модуль генерации мира без изменения остальной системы.

- **Слабая связность между системами:** разные системы проекта не знают подробностей работы друг друга. Между системами передаются только данные или события – например, система «Пользовательские настройки» может поменять параметры, а система «Графика» подписана и применит их, но они не вызывают методы друг друга напрямую.

- **Такой подход обеспечивает масштабируемость:** новые системы и модули могут добавляться без изменения существующих, а тестировать и разрабатывать их можно по отдельности.

### Взаимодействие и оркестрация систем
- Системы приложения могут взаимодействовать разными способами, избегая жёсткой связи. Рассмотрим основные стратегии:

- **Через событийную шину (Event Bus):** компоненты различных систем общаются через общую шину событий инфраструктуры. Например, после создания карты модуль «Генератор карты» публикует событие с данными карты, а модуль «Генератор мобов» подписан на него и, получив данные, начинает создавать врагов на карте. Ни один из модулей не хранит ссылки на другой – обмен идёт через сообщение. `Zenject Signals` (или аналогичные системы сообщений) используются именно для такого лёгкого уведомления о событиях без передачи данных.

- **Оркестратор (дирижёр) систем:** создаётся специальный компонент (например, `GameManager` или `LevelDirector`), который управляет последовательностью действий в системах. Он может поочерёдно вызывать методы разных систем и передавать им результаты. Например, дирижёр сначала вызывает GenerateMap(), получает объекты карты, а затем передаёт их в SpawnMobs(mapData). Генератор карты и генератор мобов сами друг о друге не знают – их связывает оркестратор. Такой паттерн упрощает последовательную работу систем и сохраняет их разобщённость.

- **Прямая DI-связь (когда уместно):** если взаимодействие двух систем всегда детерминировано и предполагается жёсткая последовательность, можно внедрить одну систему в другую через Zenject. Например, напрямую передать интерфейс `IMobGenerator` в `MapGenerator`. Этот подход удобен для простоты, но его следует применять с осторожностью: он допустим только там, где связь постоянна и не нарушает принципы модульности. Если такой связи нет в требованиях или она может меняться, лучше использовать оркестратор или события.

**Пример:** Есть система генерации уровня и система спавна врагов.
- Вариант 1 – событийный: система уровня публикует LevelGeneratedEvent{levelData}, а система врагов подписана и реагирует.
- Вариант 2 – дирижёр: компонент LevelManager сначала вызывает генерацию уровня, получает levelData, затем явно вызывает SpawnEnemies(levelData).
  > В обоих случаях сами генератор уровня и спаунер врагов не знают друг о друге и работают только со своими входными/выходными данными.

> Такой подход к оркестрации позволяет максимально ослабить связь между системами: они обмениваются только данными и реагируют на события, а не вызывают методы друг друга напрямую. Это делает архитектуру гибкой и расширяемой.

## Минимизация использования MonoBehaviour
MonoBehaviour-скрипты нужны Unity для прикрепления компонентов к игровым объектам, но они накладны. В официальной документации Unity указывается: «ScriptableObjects легче, чем MonoBehaviours, и не несут накладных расходов, связанных с последними»
Аналогично Zenject подчёркивает: иногда предпочтительнее избежать «избыточного веса» MonoBehaviour и использовать обычные C# классы.
Таким образом бизнес-логику рекомендуется выносить в независимые классы (или ScriptableObject), а MonoBehaviour применять лишь для интеграции с Unity (отображение, ввод, управление сценой и т.д.).

### Примеры
**Пример (здоровье):** Логику «здоровья» можно вынести в отдельный класс или `ScriptableObject` (не желательно), а не использовать MonoBehaviour. Например, доменная модель² `Health` публикует события при получении урона, а MonoBehaviour-скрипт лишь визуализирует текущее значение. Компонент, отвечающий за здоровье и получение урона, можно прилепить и игроку, и противникам, и даже препятствиям. Сам MonoBehaviour может быть просто композитом, который содержит скрипт здоровья и предоставляет его другим объектам через интерфейсы (контракты).
Аналогичный подход используется и в других системах (очки опыта, инвентарь и т.д.): их данные остаются в простых классах или данных, а MonoBehaviour-скрипты только обрабатывают события.

## Принцип выбора архитектуры
Хотя в документе описаны рекомендации по модулям, системам, Zenject и взаимодействию между ними, конечное решение о конкретной реализации архитектуры всегда остаётся за разработчиком или тим-лидом проекта.

Рекомендации служат ориентиром и помогают соблюсти слабую связность, модульность и управляемость системы.

В реальном проекте могут возникнуть ситуации, когда удобнее слегка отклониться от правил (например, использовать прямую DI-связь между системами для упрощения логики или ускорения разработки).

Выбор конкретных паттернов, способов оркестрации систем и детализации модулей всегда определяется командой исходя из требований проекта, сроков и масштабируемости.

- **Идея:** документ задаёт архитектурный каркас и лучшие практики, но не заменяет здравый смысл и опыт разработчиков.

## Итоговая концепция архитектуры
Архитектура проекта сочетает модульную структуру и организацию систем, чтобы одновременно разделять ответственность и сохранять автономность компонентов.

Модули и системы независимы и взаимодействуют через события и сервисы. Автономность позволяет заменять и развивать компоненты без влияния на остальное. Готовая библиотека модулей (15–20 механик) создаёт **конвейер игр:** механики быстро комбинируются в новые проекты, ускоряя разработку, прототипирование и тестирование идей, экономя ресурсы и упрощая поддержку.
